class _CheckingState extends State<Checking> {
  Map<int, String> selectedans = {};
  bool all = true;
  bool attended = false;
  bool unattended = false;

  void _loadSavedAnswer() async {
    final prefs = await SharedPreferences.getInstance();
    for (int i = 0; i < widget.randomelements.length; i++) {
      final id = widget.randomelements[i]['id'];
      final answer = prefs.getString('set_${widget.setnumber}_QN_$id');
      if (answer != null) {
        selectedans[i] = answer;
      }
    }
    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Row(
          children: [
            ElevatedButton(
              onPressed: () {
                setState(() {
                  all = true;
                  attended = false;
                  unattended = false;
                });
              },
              child: Text('All'),
            ),
            ElevatedButton(
              style: ElevatedButton.styleFrom(backgroundColor: Colors.green),
              onPressed: () {
                setState(() {
                  all = false;
                  attended = true;
                  unattended = false;
                });
              },
              child: Text('Attended'),
            ),
            ElevatedButton(
              style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
              onPressed: () {
                setState(() {
                  all = false;
                  attended = false;
                  unattended = true;
                });
              },
              child: Text('UnAttended'),
            ),
          ],
        ),
      ),
      body: Padding(
        padding: EdgeInsets.symmetric(horizontal: 15.w),
        child: GridView.builder(
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 5, childAspectRatio: 1.5),
          itemCount: all
              ? widget.randomelements.length
              : attended
                  ? widget.attemptedQuestions.length
                  : widget.randomelements.length -
                      widget.attemptedQuestions.length,
          itemBuilder: (context, index) {
            int questionIndex;
            if (all) {
              questionIndex = index;
            } else if (attended) {
              questionIndex = widget.attemptedQuestions[index];
            } else {
              int count = 0;
              for (int i = 0; i < widget.randomelements.length; i++) {
                if (!widget.attemptedQuestions.contains(i)) {
                  if (count == index) {
                    questionIndex = i;
                    break;
                  }
                  count++;
                }
              }
            }
            final question = widget.randomelements[questionIndex];
            final id = question['id'];
            final body = question['body'];
            final answers = question['answers'] as List;
            final questionnumber = questionIndex + 1;
            return Padding(
              padding: EdgeInsets.all(8.0.r),
              child: Container(
                decoration: BoxDecoration(
                  border: widget.attemptedQuestions.contains(questionIndex)
                      ? Border.all()
                      : null,
                  color: widget.attemptedQuestions.contains(questionIndex)
                      ? const Color.fromARGB(255, 225, 222, 222)
                      : const Color.fromARGB(255, 239, 238, 238),
                ),
                child: Center(
                  child: Text('$questionnumber',
                      style: widget.attemptedQuestions.contains(questionIndex)
                          ? TextStyle(fontWeight: FontWeight.bold)
                          : null),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}